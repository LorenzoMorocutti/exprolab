<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Exprolab_assignment3: Experimental Robotics Laboratory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Exprolab_assignment3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Experimental Robotics Laboratory </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the repository for the third assignment of the experimental robotics course of Unige.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Description of the repository</h1>
<p>In the repository it's possible to find:</p><ul>
<li><em>launch</em> folder: contains the launch files;</li>
<li><em>models</em> folder: contains the models for the markers;</li>
<li><em>msg</em> folder: contains the structure of the ErlOracle messagge;</li>
<li><em>param</em> folder: contains some .yaml files with some parameters for the robot and other aspects;</li>
<li><em>scripts</em> folder: contains three .py nodes for the assignment;</li>
<li><em>src</em> folder: contains a cpp node for the assignment;</li>
<li><em>srv</em> folder: contains the structure of the services used in the assignment;</li>
<li><em>urdf</em> folder: contains the structure of the robot used in the simulation;</li>
<li><em>worlds</em> folder: contains the folder with the world for the simulation.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Software Architecture</h1>
<p>We can see in the image below the component diagram of the software:</p>
<p><img src="images_videos/component_diagram.jpg" alt="immagine" class="inline"/></p>
<ul>
<li><b><a class="el" href="namespace_f_s_m.html">FSM</a></b>: The <code><a class="el" href="namespace_f_s_m.html">FSM</a></code> node is the "administrator" of the whole application: it's the node that implements the state machine that rules when the other nodes have to be called. It consists of 4 different states, that will be seen more in detail later on;</li>
<li><b>simulation</b>: The <code>simulation</code> node has the role to give information about the hints associated to the markers (it gived the fields of the hint as an ErlOracle.msg) to <a class="el" href="namespacemanage__hint.html">manage_hint</a> and the winning ID (oracle_solution) to node_hint;</li>
<li><b><a class="el" href="namespacemanage__hint.html">manage_hint</a></b>: The <code><a class="el" href="namespacemanage__hint.html">manage_hint</a></code> node implements the behaviour to retrieve all the hints. Firstly, it receives the hints published by the Aruco node; then requests the complete hint to the simulation node; at last makes an hintRequest to node_hint to manage all the interactions with ARMOR;</li>
<li><b>node_hint</b>: Also the <code>node_hint</code> node is very important; indeed it manages everything about the hints received: it loads the ontology and keeps it updated; it check if the hypotesis (that comprehends a 'what', a 'where' and a 'who' field belonging to the same ID) is complete and consistent; sends to the <a class="el" href="namespace_f_s_m.html">FSM</a> all the checks needed and the field of the winning ID (when we have enoguh hints about that). All of this is possible thanks to the armor node;</li>
<li><b>ARMOR</b>: The <code>ARMOR</code> node is the one that "answers" to all the requests that comes from the node_hint about the ontology and management of the hypotesis.</li>
</ul>
<p>In the image is also possible to see which services/topics are used to communicate between the nodes (the lollipop is used for the services while the double arrow is used for the topics of the publishers/subscribers).</p>
<p>About the nodes, it is been also reported the rqt_graph in which are seen only the topics of he publishers/subscribers:</p>
<p><img src="images_videos/rqt_graph.jpg" alt="immagine" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md3"></a>
State diagram</h2>
<p>In the following image is reported the state diagram, that is the description of the connections between the states of the fsm:</p>
<p><img src="images_videos/state_diagram.jpg" alt="immagine" class="inline"/></p>
<ul>
<li>The robot starts in the <em>Goto_new_room</em> state, that in our application is possible thanks to the action MoveBaseGoal, where we set our destination and it manages all the velocities to reach that point;</li>
<li>Then we always go to the <em>Look_for_hint</em> state where we move the robotic arm (thanks to the moveit libraries) and the robot (publish an angular velocity around z via /cmd_vel to move it in the clockwise and counter-clockwise direction) and check if there is any marker that contains an hint;</li>
<li>If we have enough hints to make a complete and consistent hypotesis, it goes home, otherwise it returns to the goto_new_rom state;</li>
<li>If the hypotesis is complete and consistent we want to check if it's the winning one, so we return home thanks to the <em>Go_home</em> state (same as the goto_new_room);</li>
<li>Finally, in <em>Check_result</em>, we confirms if the hypotesis is the winning one and if it is the goal is reached and we can exit the state machine, otherwise we return to goto_new_room to look for other hints.</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Temporal diagram</h2>
<p>In the following image is represented the temporal diagram, of the software:</p>
<p><img src="images_videos/temporal_diagram.jpg" alt="immagine" class="inline"/></p>
<p>It shows in a explicit way the temporal connections of the nodes: we can see that everything starts at the <a class="el" href="namespace_f_s_m.html">FSM</a> node and ends there. The temporal passagges (when the services/topics are called) are to be read from the top to bottom of the diagram (the upper one is the first step, the lower one is the last).</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Services</h2>
<p>The custom services used in the software are the following:</p>
<ul>
<li><em>hint</em>: the service used to pass all the fields of an hint, when requested. The response is a boolean, True if the hint is ok or False if it's malformed: <br  />
 <div class="fragment"><div class="line">int32 ID</div>
<div class="line">string key</div>
<div class="line">string value</div>
<div class="line">---</div>
<div class="line">bool check</div>
</div><!-- fragment --></li>
<li><em>correct_hyp</em>: the service used to check if there is at least a complete and consistent hypotesis. The response is a string of all the IDs of the hypotesis of this type: <div class="fragment"><div class="line">bool t</div>
<div class="line">---</div>
<div class="line">string hypotesis</div>
</div><!-- fragment --></li>
<li><em>print_res</em>: service used to send all the fields of the winning hypotesis when requested: <div class="fragment"><div class="line">int32 ID</div>
<div class="line">---</div>
<div class="line">string who</div>
<div class="line">string what</div>
<div class="line">string where</div>
</div><!-- fragment --></li>
<li><em>Marker</em>: service that receives a marker_id as a request and return all the fields associated to that id (as a ErlOracle.msg): <div class="fragment"><div class="line">int32 markerId</div>
<div class="line">---</div>
<div class="line">exprolab_ass3/ErlOracle oracle_hint</div>
</div><!-- fragment --></li>
<li><em>Oracle</em>: service that sends the winning ID when requested: <div class="fragment"><div class="line">---</div>
<div class="line">int32 ID</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Messages</h2>
<p>The only message used in the software is the <em>ErlOracle</em>, that contains all the fields of a generic hint: </p><div class="fragment"><div class="line">int32 ID</div>
<div class="line">string key</div>
<div class="line">string value</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Smach State Machine</h2>
<p>The implementation of the finite state machine has been done thanks to the <code>smach</code> library, in which we have just to write the code to be executed at each state. There is also a useful tool that is <code>smach_viewer</code> that allows us to visualize the structure of the fsm:</p>
<p><img src="images_videos/smach_fsm.jpg" alt="immagine" class="inline"/></p>
<p>The image, as expected, is the same as the state diagram.</p>
<p>It is possible, in the terminal, to see the following screenshots relative to the fsm:</p>
<p><img src="images_videos/go_home.jpg" alt="immagine" class="inline"/></p>
<p>In this image I want to show that, when there is a hypotesis complete to check, the terminal change state from <em>look_for_hint</em> to <em>go_home</em>;</p>
<p>In the second image is possible to see the final result (after a checking of the winning id, to be sure that it's the correct hypotesis), where the state change from <em>go_home</em> to <em>check_result</em> and eventually (if the hypotesis is not correct, it would just return to <em>goto_new_room</em>) to <em>Goal</em> that is the exit of the state machine:</p>
<p><img src="images_videos/check_result.jpeg.jpeg" alt="immagine" class="inline"/></p>
<p>The ID: 0 was the correct answer, so we can also see the final print of the culprit.</p>
<p>I also put a brief video that shows the highlights of the simulation that I will explain before the vision:</p><ul>
<li><em>first part</em>: in this section we can see the start of the simulation where the robots go to the first room (I also show some of the hints that the robot receives while moving);</li>
<li><em>second part</em>: in this section I want to show how the robot moves during the <em>look_for_hint</em> state;</li>
<li><em>third part</em>: I want to show how it changes room again. This procedure will last until the robot has enough hints to make a complete hypotesis, then it will go home to check the result.</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=jnmkNVaa2HE">click to the video</a></p>
<h1><a class="anchor" id="autotoc_md8"></a>
Running the code</h1>
<p>To run the code we have to follows few steps:</p><ul>
<li><em>first</em>: clone the Aruco package from the github repository of the professor <a href="https://github.com/CarmineD8">Carmine Recchiuto</a> <a href="https://github.com/CarmineD8/aruco_ros.git">link_to_Aruco</a> in the src folder of the catkin workspace with the command:</li>
</ul>
<div class="fragment"><div class="line">git clone https://github.com/CarmineD8/aruco_ros.git</div>
</div><!-- fragment --><ul>
<li><em>second</em>: clone this repositiory in the src folder of the catkin workspace: <div class="fragment"><div class="line">git clone https://github.com/LorenzoMorocutti/exprolab.git</div>
<div class="line">cd exprolab</div>
<div class="line">git checkout assignment3</div>
</div><!-- fragment --></li>
</ul>
<p>and move the <a class="el" href="namespaceexprolab__ass3.html">exprolab_ass3</a> folder in the src folder;</p><ul>
<li><em>third</em>: copy the content of the folder <code>models</code> in the folder <code>.gazebo</code> in the root;</li>
<li><em>fourth</em>: go to the scripts folder and make the .py files executable with the command: <div class="fragment"><div class="line">chmod +x script1_name.py script2_name.py ...</div>
</div><!-- fragment --></li>
</ul>
<p>for every .py file;</p><ul>
<li><em>fifth</em>: go to the catkin workspace folder and run <code>catkin_make</code>;</li>
</ul>
<p>Then we have to open three tabs in the terminal:</p><ul>
<li><em>first tab</em>: digit <div class="fragment"><div class="line">roslaunch exprolab_ass3 simulation.launch</div>
</div><!-- fragment --></li>
<li><em>second tab</em>: digit <div class="fragment"><div class="line">rosrun exprolab_ass3 FSM.py</div>
</div><!-- fragment --></li>
<li><em>third tab</em>: digit <div class="fragment"><div class="line">rosrun exprolab_ass3 manage_hint.py</div>
</div><!-- fragment --></li>
</ul>
<p>to launch all the nodes.</p>
<p>I chose to manage all the launching like this because (personal opinion) it's easier to monitor the changes of the state machine and the hint received (we can look at them in the <a class="el" href="namespacemanage__hint.html">manage_hint</a> tab).</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Working Hypotesis and Environment</h1>
<p>The environment in which the robot moves is a Gazebo simulation. As the previous assignment, the hints are given by the author professor <a href="http://github.com/CarmineD8">Carmine Recchiutto</a>, so I just had to deal with them (by reading the markers and then retrieving the hint). All about the hints remains valid from the first two assignments.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
System's Features</h2>
<p>The architecture is definitely modular: each node execute small task, so we can change them to adapt the software to new implementations (basically I reused a lot of code from the first assignment, the manage of the hints by node_hint is the exact same). The system is thus very robust.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
System's Limitations</h2>
<p>The hints managed by the robot aren't modifiable (they are, but the goal of the assignment is to manage hints not written by the user) but the ontology is not readable when updated and the terminal output is difficult to read if someone is not familiar with the outputs (in the state machine terminal there are information about moveit that cannot be canceled, so we have to look carefully to the useful information). The simulation is very slow so it's very difficult to debug the code (there are definitely some shortcuts, for example, from the terminal we can publish hints on the topic /oracle_hint to give the robot a complete hypotesis directly, to test the check_complete and check_result). Differently from the last assignment, I tried this code on other PCs and it seems like it works on every device (so there are not bugs relative to any package, I would say).</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Possible Techical Improvements</h2>
<p>Some improvements concern the velocity of the simulation that could be way faster if the move_base and moveit codes were optimized (in particular moveit is very slow). The movement of the robotic arm could be more accurate to check EVERY marker (some of them are not catched or so it seems). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
