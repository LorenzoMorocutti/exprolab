# Experimental Robotics Laboratory
This is the repository for the second assignment of the experimental robotics course of Unige.

## Description of the repository
In the repository it's possible to find:
* *action* folder: contains the structure of the Moving action;
* *common* folder: contains the plan and the problem generated by ROSplan;
* *config* folder: contains the rviz simulation file;
* *include* folder: contains the header of the ActionInterface;
* *launch* folder: contains the launch files;
* *msg* folder: contains the structure of the ErlOracle messagge;
* *scripts* folder: contains scripts of three nodes of the assignment; 
* *src* folder: contains the cpp codes associated to the actions and the simulation;
* *srv* folder: contains the structure of the services used in the assignment;
* *urdf* folder: contains the urdf model of the robot used;
* *world* folder: contains the world file used for the simulation environment;
* *domain and problem*: pddl files used by ROSplan;
* *script.sh*: shell script.

## Software Architecture
We can see in the image below the component diagram of the software:

![immagine](images/component_diagram.jpg)

* **node_hint**: The `node_hint` node implements the node that receives the hint from the oracle and saves it in the ontology. The armor node will tell us if the hint is malformed or valid. It also implements the checking of the completeness and consistency of the hypothesis. Eventually retrieves the field of an hypothesis from the ontology, given an ID;
* **generation_problem**: The `generation_problem` node implements the various calls to ROSplan to generate the plan run by the robot. It requests feedback from the plan and produces new plans until the goal is reached. It also updates the knowedge base;
* **go_to_point**: The `go_to_point` node controls the behavior of the robot according to the go_to_point behavior via an action server. A FSM is used to model the behavior every time a new goal pose is received: firstly the robot alight its position with the goal's one, then it goes straight to the goal position, it aligns with the goal orientation and then the goal pose is reached;
* **Moveto**: This node implements the 'move_to' pddl action to a waypoint. This is possible thanks to the go_to_point node;
* **Moveaway**: This node implements the 'move_away_from_home' pddl action to move the robot from home to the waypoint chosen by the planner. This is possible thanks to the go_to_point node;
* **Movehome**: This node implements the 'move_home' pddl action to return to the home waypoint. This is possible thanks to the go_to_point node;
* **Checkhint**: This node implements the 'check_hint' pddl action to move the robotic arm to look for the hint. It uses the 'moveit' library to do so;
* **Checkcomplete**: This node implements the 'check_complete_hypotesis' pddl action to check if the passed hypotesis is complete and consistent;
* **Checkresult**: This node implements the 'check_result' pddl action to check if the complete hypotesis is the correct one and, in that case, print the solution.
* **ARMOR**: The `ARMOR` node is the one that "answers" to all the requests that comes from the node_hint about the ontology and management of the hypotesis.

In the image is also possible to see which services/topics are used to communicate between the nodes (the lollipop is used for the services while the double arrow is used for the topics of the publishers/subscribers).

About the nodes, it is been also reported the rqt_graph in which are seen only the topics of he publishers/subscribers:

![immagine](images/rqt_graph.jpeg)

### State diagram
In the following image is reported the state diagram, that is the description of the connections between the states of the fsm:

![immagine](images/state_diagram.jpeg)

The robot starts in the *Goto_new_room* state, that in our application is basically a sleep (it should simulates the time the robot needs to change the room); then we always go to the *Look_for_hint* states where we receive a hint from the oracle and, if it has enough hints to make a complete hypotesis, it goes home, otherwise it returns to the goto_new_rom state; if the hypotesis is complete and consistent we want to check if it's the winning one, so we return home thanks to the *Go_home* state, that is again a simulation of the movement of returning home (implemented by a sleep); finally, in *Check_result* we confirms if the hypotesis is the winning one and if it is the goal is reached and we can exit the state machine, otherwise we return to goto_new_room to look for other hints.

### Temporal diagram
In the following image is represented the temporal diagram, of the software:

![immagine](images/temporal_diagram.jpg)

It shows in a explicit way the temporal connections of the nodes: we can see that everything starts at the FSM node and ends there. The temporal passagges (when the services/topics are called) are to be read from the top to bottom of the diagram (the upper one is the first step, the lower one is the last).

### Actions
The only action used in the software is *Moving*, that contains all the information about the goal position and the robot position:
```
geometry_msgs/PoseStamped target_pose
---
geometry_msgs/Pose actual_pose
---
string stat
```
The request is of the type geometry_msgs and the response is composed by a geometry_msgs and a string.

### Services
The custom services used in the software are the following:

* *hint*: the service used to pass all the fields of an hint, when requested. The response is a boolean, True if the hint is ok or False if it's malformed:  
```
int32 ID
string key
string value
---
bool check
```

* *correct_hyp*: the service used to check if there is at least a complete and consistent hypotesis. The response is a string of all the IDs of the hypotesis of this type:
```
bool t
---
string hypotesis
```

* *print_res*: the service used to request/send the fields of the winning hypotesis. The request is the ID while the response are the field of the hypotesis:
```
int32 ID
---
string who
string where
string what
```

* *Oracle*: the service used to request the ID of the winning hypotesis:
```
---
int32 ID
```

* *Position*: the service used to set the postion to reach:
```
float32 x
float32 y
float32 theta
---
bool ok
```

### Messages
The only message used in the software is the *ErlOracle*, that contains all the fields of a generic hint:
```
int32 ID
string key
string value
```

### PDDL 
Relative to the planning part, there are the following files:
* `domain.pddl`: the domain file used by the planner where are defined all the predicates and actions;
* `problem.pddl`: the problem file used by the planner to read the objects to use in the plan and the goal state we want to achieve;
* `new_problem`: in the folder *common*, the problem generated by ROSplan (same as the file afore mentioned);
* `plan`: in the folder *common*, the plan we want to follow (id something goes wrong, we have to replan). This file can change during the execution of the plan.

